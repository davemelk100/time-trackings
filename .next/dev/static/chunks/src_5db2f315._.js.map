{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/davemelkonian/Movies/repos/time-trackings/src/components/theme-provider.tsx"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\nimport {\n  ThemeProvider as NextThemesProvider,\n  type ThemeProviderProps,\n} from 'next-themes'\n\nexport function ThemeProvider({ children, ...props }: ThemeProviderProps) {\n  return <NextThemesProvider {...props}>{children}</NextThemesProvider>\n}\n"],"names":[],"mappings":";;;;;AAGA;AAHA;;;AAQO,SAAS,cAAc,EAAE,QAAQ,EAAE,GAAG,OAA2B;IACtE,qBAAO,6LAAC,oKAAkB;QAAE,GAAG,KAAK;kBAAG;;;;;;AACzC;KAFgB"}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///Users/davemelkonian/Movies/repos/time-trackings/src/lib/supabase.ts"],"sourcesContent":["import { createClient as createSupabaseClient, type SupabaseClient } from \"@supabase/supabase-js\"\nimport type { TimeEntry, Subscription, Attachment, Client, Payable, Invoice, Link } from \"./project-data\"\n\nexport function createClient() {\n  return createSupabaseClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n  )\n}\n\n// ── Clients CRUD ────────────────────────────────────────────────────\n\nexport interface ClientRow {\n  id: string\n  name: string\n  hourly_rate: number | null\n  flat_rate: number | null\n  billing_period_start: string | null\n  billing_period_end: string | null\n  created_at: string\n}\n\nexport function rowToClient(row: ClientRow): Client {\n  return {\n    id: row.id,\n    name: row.name,\n    hourlyRate: row.hourly_rate != null ? Number(row.hourly_rate) : null,\n    flatRate: row.flat_rate != null ? Number(row.flat_rate) : null,\n    billingPeriodStart: row.billing_period_start ?? null,\n    billingPeriodEnd: row.billing_period_end ?? null,\n  }\n}\n\nexport async function fetchClients(supabase: SupabaseClient): Promise<Client[]> {\n  const { data, error } = await supabase\n    .from(\"clients\")\n    .select(\"*\")\n    .order(\"name\", { ascending: true })\n\n  if (error) throw error\n  return (data as ClientRow[]).map(rowToClient)\n}\n\nexport async function insertClient(\n  supabase: SupabaseClient,\n  client: { id: string; name: string; hourlyRate: number | null; flatRate: number | null },\n): Promise<void> {\n  const { error } = await supabase.from(\"clients\").insert({\n    id: client.id,\n    name: client.name,\n    hourly_rate: client.hourlyRate,\n    flat_rate: client.flatRate,\n  })\n  if (error) throw error\n}\n\nexport async function deleteClient(supabase: SupabaseClient, id: string): Promise<void> {\n  const { error } = await supabase.from(\"clients\").delete().eq(\"id\", id)\n  if (error) throw error\n}\n\nexport async function updateClientRate(\n  supabase: SupabaseClient,\n  clientId: string,\n  hourlyRate: number | null,\n  flatRate: number | null,\n): Promise<void> {\n  const { error } = await supabase\n    .from(\"clients\")\n    .update({ hourly_rate: hourlyRate, flat_rate: flatRate })\n    .eq(\"id\", clientId)\n  if (error) throw error\n}\n\nexport async function updateClientBillingPeriodStart(\n  supabase: SupabaseClient,\n  clientId: string,\n  date: string | null,\n): Promise<void> {\n  const { error } = await supabase\n    .from(\"clients\")\n    .update({ billing_period_start: date })\n    .eq(\"id\", clientId)\n  if (error) throw error\n}\n\nexport async function updateClientBillingPeriodEnd(\n  supabase: SupabaseClient,\n  clientId: string,\n  date: string | null,\n): Promise<void> {\n  const { error } = await supabase\n    .from(\"clients\")\n    .update({ billing_period_end: date })\n    .eq(\"id\", clientId)\n  if (error) throw error\n}\n\n// ── snake_case ↔ camelCase mappers ──────────────────────────────────\n\nexport interface TimeEntryRow {\n  id: string\n  client_id: string\n  date: string\n  start_time: string\n  end_time: string\n  time_range: string\n  total_hours: number\n  tasks: string\n  notes: string\n  attachments: Attachment[]\n  links: Link[]\n}\n\nexport interface SubscriptionRow {\n  id: string\n  client_id: string\n  name: string\n  category: string\n  billing_cycle: \"monthly\" | \"annual\"\n  amount: number\n  renewal_date: string | null\n  notes: string\n  attachments: Attachment[]\n  links: Link[]\n}\n\nexport function rowToTimeEntry(row: TimeEntryRow): TimeEntry {\n  return {\n    id: row.id,\n    date: row.date,\n    startTime: row.start_time,\n    endTime: row.end_time,\n    timeRange: row.time_range,\n    totalHours: Number(row.total_hours),\n    tasks: row.tasks,\n    notes: row.notes,\n    attachments: Array.isArray(row.attachments) ? row.attachments : [],\n    links: Array.isArray(row.links) ? row.links : [],\n  }\n}\n\nexport function timeEntryToRow(entry: TimeEntry, clientId: string): Omit<TimeEntryRow, \"id\"> & { id?: string } {\n  return {\n    id: entry.id,\n    client_id: clientId,\n    date: entry.date,\n    start_time: entry.startTime,\n    end_time: entry.endTime,\n    time_range: entry.timeRange,\n    total_hours: entry.totalHours,\n    tasks: entry.tasks,\n    notes: entry.notes,\n    attachments: entry.attachments ?? [],\n    links: entry.links ?? [],\n  }\n}\n\nexport function rowToSubscription(row: SubscriptionRow): Subscription {\n  return {\n    id: row.id,\n    name: row.name,\n    category: row.category,\n    billingCycle: row.billing_cycle,\n    amount: Number(row.amount),\n    renewalDate: row.renewal_date ?? \"\",\n    notes: row.notes,\n    attachments: Array.isArray(row.attachments) ? row.attachments : [],\n    links: Array.isArray(row.links) ? row.links : [],\n  }\n}\n\nexport function subscriptionToRow(sub: Subscription, clientId: string): Omit<SubscriptionRow, \"id\"> & { id?: string } {\n  return {\n    id: sub.id,\n    client_id: clientId,\n    name: sub.name,\n    category: sub.category,\n    billing_cycle: sub.billingCycle,\n    amount: sub.amount,\n    renewal_date: sub.renewalDate || null,\n    notes: sub.notes,\n    attachments: sub.attachments ?? [],\n    links: sub.links ?? [],\n  }\n}\n\n// ── Cross-client queries (for reports) ──────────────────────────────\n\nexport interface TimeEntryWithClient extends TimeEntry {\n  clientId: string\n}\n\nexport interface SubscriptionWithClient extends Subscription {\n  clientId: string\n}\n\nexport interface PayableWithClient extends Payable {\n  clientId: string\n}\n\nexport async function fetchAllTimeEntries(supabase: SupabaseClient): Promise<TimeEntryWithClient[]> {\n  const { data, error } = await supabase\n    .from(\"time_entries\")\n    .select(\"*\")\n    .order(\"date\", { ascending: false })\n\n  if (error) throw error\n  return (data as (TimeEntryRow & { client_id: string })[]).map((row) => ({\n    ...rowToTimeEntry(row),\n    clientId: row.client_id,\n  }))\n}\n\nexport async function fetchAllSubscriptions(supabase: SupabaseClient): Promise<SubscriptionWithClient[]> {\n  const { data, error } = await supabase\n    .from(\"subscriptions\")\n    .select(\"*\")\n    .order(\"name\", { ascending: true })\n\n  if (error) throw error\n  return (data as (SubscriptionRow & { client_id: string })[]).map((row) => ({\n    ...rowToSubscription(row),\n    clientId: row.client_id,\n  }))\n}\n\nexport async function fetchAllPayables(supabase: SupabaseClient): Promise<PayableWithClient[]> {\n  const { data, error } = await supabase\n    .from(\"payables\")\n    .select(\"*\")\n    .order(\"date\", { ascending: false })\n\n  if (error) throw error\n  return (data as (PayableRow & { client_id: string })[]).map((row) => ({\n    ...rowToPayable(row),\n    clientId: row.client_id,\n  }))\n}\n\n// ── Time Entries CRUD ───────────────────────────────────────────────\n\nexport async function fetchTimeEntries(supabase: SupabaseClient, clientId: string): Promise<TimeEntry[]> {\n  const { data, error } = await supabase\n    .from(\"time_entries\")\n    .select(\"*\")\n    .eq(\"client_id\", clientId)\n    .is(\"invoice_id\", null)\n    .order(\"date\", { ascending: true })\n\n  if (error) throw error\n  return (data as TimeEntryRow[]).map(rowToTimeEntry)\n}\n\nexport async function upsertTimeEntry(supabase: SupabaseClient, entry: TimeEntry, clientId: string): Promise<void> {\n  const row = timeEntryToRow(entry, clientId)\n  const { error } = await supabase.from(\"time_entries\").upsert(row)\n  if (error) throw error\n}\n\nexport async function deleteTimeEntry(supabase: SupabaseClient, id: string): Promise<void> {\n  const { error } = await supabase.from(\"time_entries\").delete().eq(\"id\", id)\n  if (error) throw error\n}\n\nexport async function seedTimeEntries(supabase: SupabaseClient, entries: TimeEntry[], clientId: string): Promise<void> {\n  const rows = entries.map((e) => {\n    const row = timeEntryToRow(e, clientId)\n    // Let Supabase generate UUIDs for seeded data\n    delete row.id\n    return row\n  })\n  const { error } = await supabase.from(\"time_entries\").insert(rows)\n  if (error) throw error\n}\n\n// ── Subscriptions CRUD ──────────────────────────────────────────────\n\nexport async function fetchSubscriptions(supabase: SupabaseClient, clientId: string): Promise<Subscription[]> {\n  const { data, error } = await supabase\n    .from(\"subscriptions\")\n    .select(\"*\")\n    .eq(\"client_id\", clientId)\n    .is(\"invoice_id\", null)\n    .order(\"name\", { ascending: true })\n\n  if (error) throw error\n  return (data as SubscriptionRow[]).map(rowToSubscription)\n}\n\nexport async function upsertSubscription(supabase: SupabaseClient, sub: Subscription, clientId: string): Promise<void> {\n  const row = subscriptionToRow(sub, clientId)\n  const { error } = await supabase.from(\"subscriptions\").upsert(row)\n  if (error) throw error\n}\n\nexport async function deleteSubscription(supabase: SupabaseClient, id: string): Promise<void> {\n  const { error } = await supabase.from(\"subscriptions\").delete().eq(\"id\", id)\n  if (error) throw error\n}\n\nexport async function seedSubscriptions(supabase: SupabaseClient, subs: Subscription[], clientId: string): Promise<void> {\n  const rows = subs.map((s) => {\n    const row = subscriptionToRow(s, clientId)\n    delete row.id\n    return row\n  })\n  const { error } = await supabase.from(\"subscriptions\").insert(rows)\n  if (error) throw error\n}\n\n// ── Payables CRUD ───────────────────────────────────────────────────\n\nexport interface PayableRow {\n  id: string\n  client_id: string\n  description: string\n  amount: number\n  date: string\n  paid: boolean\n  paid_date: string | null\n  notes: string\n  attachments: Attachment[]\n  links: Link[]\n}\n\nexport function rowToPayable(row: PayableRow): Payable {\n  return {\n    id: row.id,\n    description: row.description,\n    amount: Number(row.amount),\n    date: row.date,\n    paid: row.paid,\n    paidDate: row.paid_date ?? \"\",\n    notes: row.notes,\n    attachments: Array.isArray(row.attachments) ? row.attachments : [],\n    links: Array.isArray(row.links) ? row.links : [],\n  }\n}\n\nexport function payableToRow(p: Payable, clientId: string): Omit<PayableRow, \"id\"> & { id?: string } {\n  return {\n    id: p.id,\n    client_id: clientId,\n    description: p.description,\n    amount: p.amount,\n    date: p.date,\n    paid: p.paid,\n    paid_date: p.paidDate || null,\n    notes: p.notes,\n    attachments: p.attachments ?? [],\n    links: p.links ?? [],\n  }\n}\n\nexport async function fetchPayables(supabase: SupabaseClient, clientId: string): Promise<Payable[]> {\n  const { data, error } = await supabase\n    .from(\"payables\")\n    .select(\"*\")\n    .eq(\"client_id\", clientId)\n    .is(\"invoice_id\", null)\n    .order(\"date\", { ascending: false })\n\n  if (error) throw error\n  return (data as PayableRow[]).map(rowToPayable)\n}\n\nexport async function upsertPayable(supabase: SupabaseClient, payable: Payable, clientId: string): Promise<void> {\n  const row = payableToRow(payable, clientId)\n  const { error } = await supabase.from(\"payables\").upsert(row)\n  if (error) throw error\n}\n\nexport async function deletePayable(supabase: SupabaseClient, id: string): Promise<void> {\n  const { error } = await supabase.from(\"payables\").delete().eq(\"id\", id)\n  if (error) throw error\n}\n\nexport async function deletePayableByMatch(\n  supabase: SupabaseClient,\n  clientId: string,\n  description: string,\n  amount: number,\n  date: string,\n): Promise<void> {\n  const { error } = await supabase\n    .from(\"payables\")\n    .delete()\n    .eq(\"client_id\", clientId)\n    .eq(\"description\", description)\n    .eq(\"amount\", amount)\n    .eq(\"date\", date)\n  if (error) throw error\n}\n\nexport async function updateNextierMirror(\n  supabase: SupabaseClient,\n  oldDescription: string,\n  oldAmount: number,\n  oldDate: string,\n  updated: { description: string; amount: number; date: string; notes: string; attachments: Attachment[]; links?: Link[] },\n): Promise<void> {\n  const { error } = await supabase\n    .from(\"payables\")\n    .update({\n      description: updated.description,\n      amount: updated.amount,\n      date: updated.date,\n      notes: updated.notes,\n      attachments: updated.attachments,\n      links: updated.links ?? [],\n    })\n    .eq(\"client_id\", \"nextier\")\n    .eq(\"description\", oldDescription)\n    .eq(\"amount\", oldAmount)\n    .eq(\"date\", oldDate)\n  if (error) throw error\n}\n\n// ── Attachment Storage ──────────────────────────────────────────────\n\nexport async function uploadAttachment(\n  supabase: SupabaseClient,\n  file: File,\n  clientId: string,\n  entryId: string,\n): Promise<Attachment> {\n  const timestamp = Date.now()\n  const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, \"_\")\n  const path = `${clientId}/${entryId}/${timestamp}-${safeName}`\n\n  const { error } = await supabase.storage.from(\"receipts\").upload(path, file)\n  if (error) throw error\n\n  return {\n    name: file.name,\n    path,\n    size: file.size,\n    uploadedAt: new Date().toISOString(),\n  }\n}\n\nexport function getAttachmentUrl(supabase: SupabaseClient, path: string): string {\n  const { data } = supabase.storage.from(\"receipts\").getPublicUrl(path)\n  return data.publicUrl\n}\n\nexport async function deleteAttachment(supabase: SupabaseClient, path: string): Promise<void> {\n  const { error } = await supabase.storage.from(\"receipts\").remove([path])\n  if (error) throw error\n}\n\nexport async function deleteAllAttachments(supabase: SupabaseClient, attachments: Attachment[]): Promise<void> {\n  if (attachments.length === 0) return\n  const paths = attachments.map((a) => a.path)\n  const { error } = await supabase.storage.from(\"receipts\").remove(paths)\n  if (error) throw error\n}\n\n// ── Invoices CRUD ───────────────────────────────────────────────────\n\nexport interface InvoiceRow {\n  id: string\n  client_id: string\n  invoice_number: string\n  period_start: string | null\n  period_end: string | null\n  total_time: number\n  total_subscriptions: number\n  total_payables: number\n  grand_total: number\n  notes: string\n  created_at: string\n}\n\nexport function rowToInvoice(row: InvoiceRow): Invoice {\n  return {\n    id: row.id,\n    clientId: row.client_id,\n    invoiceNumber: row.invoice_number,\n    periodStart: row.period_start ?? \"\",\n    periodEnd: row.period_end ?? \"\",\n    totalTime: Number(row.total_time),\n    totalSubscriptions: Number(row.total_subscriptions),\n    totalPayables: Number(row.total_payables),\n    grandTotal: Number(row.grand_total),\n    notes: row.notes,\n    createdAt: row.created_at,\n  }\n}\n\nexport async function fetchInvoices(supabase: SupabaseClient, clientId: string): Promise<Invoice[]> {\n  const { data, error } = await supabase\n    .from(\"invoices\")\n    .select(\"*\")\n    .eq(\"client_id\", clientId)\n    .order(\"created_at\", { ascending: false })\n\n  if (error) throw error\n  return (data as InvoiceRow[]).map(rowToInvoice)\n}\n\nexport async function fetchInvoice(supabase: SupabaseClient, invoiceId: string): Promise<Invoice | null> {\n  const { data, error } = await supabase\n    .from(\"invoices\")\n    .select(\"*\")\n    .eq(\"id\", invoiceId)\n    .single()\n\n  if (error) {\n    if (error.code === \"PGRST116\") return null\n    throw error\n  }\n  return rowToInvoice(data as InvoiceRow)\n}\n\nexport async function fetchAllInvoices(supabase: SupabaseClient): Promise<Invoice[]> {\n  const { data, error } = await supabase\n    .from(\"invoices\")\n    .select(\"*\")\n    .order(\"created_at\", { ascending: false })\n\n  if (error) throw error\n  return (data as InvoiceRow[]).map(rowToInvoice)\n}\n\nexport async function updateInvoice(\n  supabase: SupabaseClient,\n  invoiceId: string,\n  updates: { total_time?: number; grand_total?: number; notes?: string },\n): Promise<Invoice> {\n  const { data, error } = await supabase\n    .from(\"invoices\")\n    .update(updates)\n    .eq(\"id\", invoiceId)\n    .select()\n    .single()\n\n  if (error) throw error\n  return rowToInvoice(data as InvoiceRow)\n}\n\nexport async function fetchTimeEntriesByInvoice(supabase: SupabaseClient, invoiceId: string): Promise<TimeEntry[]> {\n  const { data, error } = await supabase\n    .from(\"time_entries\")\n    .select(\"*\")\n    .eq(\"invoice_id\", invoiceId)\n    .order(\"date\", { ascending: true })\n\n  if (error) throw error\n  return (data as TimeEntryRow[]).map(rowToTimeEntry)\n}\n\nexport async function fetchSubscriptionsByInvoice(supabase: SupabaseClient, invoiceId: string): Promise<Subscription[]> {\n  const { data, error } = await supabase\n    .from(\"subscriptions\")\n    .select(\"*\")\n    .eq(\"invoice_id\", invoiceId)\n    .order(\"name\", { ascending: true })\n\n  if (error) throw error\n  return (data as SubscriptionRow[]).map(rowToSubscription)\n}\n\nexport async function fetchPayablesByInvoice(supabase: SupabaseClient, invoiceId: string): Promise<Payable[]> {\n  const { data, error } = await supabase\n    .from(\"payables\")\n    .select(\"*\")\n    .eq(\"invoice_id\", invoiceId)\n    .order(\"date\", { ascending: false })\n\n  if (error) throw error\n  return (data as PayableRow[]).map(rowToPayable)\n}\n\nexport async function createInvoice(\n  supabase: SupabaseClient,\n  clientId: string,\n  options: { copySubscriptionsForward?: boolean; notes?: string; hourlyRateOverride?: number; flatRateOverride?: number; rateTbd?: boolean } = {},\n): Promise<Invoice> {\n  const { copySubscriptionsForward = false, notes = \"\", hourlyRateOverride, flatRateOverride, rateTbd = false } = options\n\n  // 1. Fetch current-period data + client info\n  const [entries, subs, payables, clients] = await Promise.all([\n    fetchTimeEntries(supabase, clientId),\n    fetchSubscriptions(supabase, clientId),\n    fetchPayables(supabase, clientId),\n    fetchClients(supabase),\n  ])\n\n  const client = clients.find((c) => c.id === clientId)\n  const hourlyRate = hourlyRateOverride !== undefined ? hourlyRateOverride : (client?.hourlyRate ?? null)\n  const flatRate = flatRateOverride !== undefined ? flatRateOverride : (client?.flatRate ?? null)\n\n  // Guard: don't create an invoice if there's nothing to archive\n  if (entries.length === 0 && subs.length === 0 && payables.length === 0) {\n    throw new Error(\"Nothing to archive – no time entries, subscriptions, or payables in the current period.\")\n  }\n\n  // 2. Compute snapshot totals\n  const totalHours = entries.reduce((sum, e) => sum + e.totalHours, 0)\n  const timeCost = rateTbd ? 0 : (flatRate != null ? flatRate : hourlyRate != null ? totalHours * hourlyRate : 0)\n\n  const monthlySubTotal = subs.reduce((sum, s) => {\n    if (s.billingCycle === \"monthly\") return sum + s.amount\n    return sum + s.amount / 12\n  }, 0)\n  const subscriptionAnnual = monthlySubTotal * 12\n\n  const payablesTotal = payables.reduce((sum, p) => sum + p.amount, 0)\n\n  const isNextier = clientId === \"nextier\"\n  const grandTotal = isNextier ? payablesTotal : timeCost + subscriptionAnnual - payablesTotal\n\n  // 3. Derive period dates from client billing fields, falling back to entry dates / today\n  const dates = entries.map((e) => e.date).filter(Boolean).sort()\n  const periodStart = client?.billingPeriodStart || dates[0] || new Date().toISOString().slice(0, 10)\n  const periodEnd = client?.billingPeriodEnd || new Date().toISOString().slice(0, 10)\n\n  // 4. Generate invoice number\n  const { count } = await supabase\n    .from(\"invoices\")\n    .select(\"*\", { count: \"exact\", head: true })\n    .eq(\"client_id\", clientId)\n  const num = ((count ?? 0) + 1).toString().padStart(3, \"0\")\n  const invoiceNumber = `INV-${clientId}-${num}`\n\n  // 5. Insert invoice row\n  const { data: invoiceData, error: invoiceError } = await supabase\n    .from(\"invoices\")\n    .insert({\n      client_id: clientId,\n      invoice_number: invoiceNumber,\n      period_start: periodStart,\n      period_end: periodEnd,\n      total_time: Math.round(timeCost * 100) / 100,\n      total_subscriptions: Math.round(subscriptionAnnual * 100) / 100,\n      total_payables: Math.round(payablesTotal * 100) / 100,\n      grand_total: Math.round(grandTotal * 100) / 100,\n      notes,\n    })\n    .select()\n    .single()\n\n  if (invoiceError) throw invoiceError\n  const invoice = rowToInvoice(invoiceData as InvoiceRow)\n\n  // 6. Stamp all current-period rows with the new invoice_id\n  const entryIds = entries.map((e) => e.id)\n  const subIds = subs.map((s) => s.id)\n  const payableIds = payables.map((p) => p.id)\n\n  if (entryIds.length > 0) {\n    const { error } = await supabase\n      .from(\"time_entries\")\n      .update({ invoice_id: invoice.id })\n      .in(\"id\", entryIds)\n    if (error) throw error\n  }\n\n  if (subIds.length > 0) {\n    const { error } = await supabase\n      .from(\"subscriptions\")\n      .update({ invoice_id: invoice.id })\n      .in(\"id\", subIds)\n    if (error) throw error\n  }\n\n  if (payableIds.length > 0) {\n    const { error } = await supabase\n      .from(\"payables\")\n      .update({ invoice_id: invoice.id })\n      .in(\"id\", payableIds)\n    if (error) throw error\n\n  }\n\n  // 8. Optionally copy subscriptions forward as new current-period entries\n  if (copySubscriptionsForward && subs.length > 0) {\n    const newSubRows = subs.map((s) => ({\n      client_id: clientId,\n      name: s.name,\n      category: s.category,\n      billing_cycle: s.billingCycle,\n      amount: s.amount,\n      renewal_date: s.renewalDate || null,\n      notes: s.notes,\n      attachments: s.attachments ?? [],\n      links: s.links ?? [],\n    }))\n    const { error } = await supabase.from(\"subscriptions\").insert(newSubRows)\n    if (error) throw error\n  }\n\n  // 9. Clear billing period dates on client after invoice creation\n  if (client?.billingPeriodStart || client?.billingPeriodEnd) {\n    const { error: clearError } = await supabase\n      .from(\"clients\")\n      .update({ billing_period_start: null, billing_period_end: null })\n      .eq(\"id\", clientId)\n    if (clearError) throw clearError\n  }\n\n  return invoice\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 570, "column": 0}, "map": {"version":3,"sources":["file:///Users/davemelkonian/Movies/repos/time-trackings/src/lib/auth-context.tsx"],"sourcesContent":["\"use client\"\n\nimport { createContext, useContext, useMemo } from \"react\"\nimport type { SupabaseClient } from \"@supabase/supabase-js\"\nimport { useRouter } from \"next/navigation\"\nimport { createClient } from \"@/lib/supabase\"\n\ninterface Session {\n  role: \"admin\" | \"client\"\n  clientId: string | null\n}\n\ninterface AuthContextValue {\n  supabase: SupabaseClient\n  isAdmin: boolean\n  clientId: string | null\n  signIn: (passcode: string) => Promise<{ error: string | null; role?: string; clientId?: string | null }>\n  signOut: () => Promise<void>\n}\n\nconst AuthContext = createContext<AuthContextValue | null>(null)\n\nexport function AuthProvider({ children, session }: { children: React.ReactNode; session: Session | null }) {\n  const supabase = useMemo(() => createClient(), [])\n  const router = useRouter()\n\n  const isAdmin = session?.role === \"admin\"\n  const clientId = session?.clientId ?? null\n\n  async function signIn(passcode: string) {\n    const res = await fetch(\"/api/auth\", {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ passcode }),\n    })\n    const data = await res.json()\n    if (!res.ok) return { error: data.error ?? \"Invalid passcode\" }\n    router.refresh()\n    return { error: null, role: data.role, clientId: data.clientId }\n  }\n\n  async function signOut() {\n    await fetch(\"/api/auth\", { method: \"DELETE\" })\n    router.push(\"/login\")\n    router.refresh()\n  }\n\n  return (\n    <AuthContext.Provider value={{ supabase, isAdmin, clientId, signIn, signOut }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const ctx = useContext(AuthContext)\n  if (!ctx) throw new Error(\"useAuth must be used within an AuthProvider\")\n  return ctx\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;AACA;;;AALA;;;;AAoBA,MAAM,4BAAc,IAAA,8KAAa,EAA0B;AAEpD,SAAS,aAAa,EAAE,QAAQ,EAAE,OAAO,EAA0D;;IACxG,MAAM,WAAW,IAAA,wKAAO;0CAAC,IAAM,IAAA,yIAAY;yCAAI,EAAE;IACjD,MAAM,SAAS,IAAA,kJAAS;IAExB,MAAM,UAAU,SAAS,SAAS;IAClC,MAAM,WAAW,SAAS,YAAY;IAEtC,eAAe,OAAO,QAAgB;QACpC,MAAM,MAAM,MAAM,MAAM,aAAa;YACnC,QAAQ;YACR,SAAS;gBAAE,gBAAgB;YAAmB;YAC9C,MAAM,KAAK,SAAS,CAAC;gBAAE;YAAS;QAClC;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,IAAI,CAAC,IAAI,EAAE,EAAE,OAAO;YAAE,OAAO,KAAK,KAAK,IAAI;QAAmB;QAC9D,OAAO,OAAO;QACd,OAAO;YAAE,OAAO;YAAM,MAAM,KAAK,IAAI;YAAE,UAAU,KAAK,QAAQ;QAAC;IACjE;IAEA,eAAe;QACb,MAAM,MAAM,aAAa;YAAE,QAAQ;QAAS;QAC5C,OAAO,IAAI,CAAC;QACZ,OAAO,OAAO;IAChB;IAEA,qBACE,6LAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAU;YAAS;YAAU;YAAQ;QAAQ;kBACzE;;;;;;AAGP;GA9BgB;;QAEC,kJAAS;;;KAFV;AAgCT,SAAS;;IACd,MAAM,MAAM,IAAA,2KAAU,EAAC;IACvB,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAC1B,OAAO;AACT;IAJgB"}}]
}